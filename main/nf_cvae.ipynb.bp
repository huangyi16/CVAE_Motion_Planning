{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import torch.nn.functional as F\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.patches as patches\n",
    "\n",
    "import time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "mb_size = 256 # batch size\n",
    "h_Q_dim = 512 # encoder hidden layers dimension\n",
    "h_P_dim = 512 # decoder hidden layers dimension\n",
    "\n",
    "c = 0\n",
    "lr = 1e-4\n",
    "\n",
    "dim = 2\n",
    "data_elements = dim + dim * 2 + 4 * 3\n",
    "z_dim = 10\n",
    "X_dim = dim * 30\n",
    "y_dim = dim * 30\n",
    "c_dim = dim * 2 + 12"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3626561, 16)\n",
      "(3626561, 60)\n"
     ]
    }
   ],
   "source": [
    "# read data from npy\n",
    "c_filename = '../dataset_c.npy'\n",
    "x_filename = '../dataset_x.npy'\n",
    "\n",
    "dataset_c = np.load(c_filename)\n",
    "dataset_x = np.load(x_filename)\n",
    "print(dataset_c.shape)\n",
    "print(dataset_x.shape)\n",
    "\n",
    "# data = np.concatenate((dataset_x, dataset_c), axis=1)\n",
    "# print(data.shape)\n",
    "\n",
    "num_data = dataset_c.shape[0]\n",
    "\n",
    "ratio_test_train = 0.8\n",
    "num_train = int(num_data * ratio_test_train)\n",
    "\n",
    "X_train = dataset_x[0: num_train, :]\n",
    "c_train = dataset_c[:num_train, :]\n",
    "\n",
    "X_test = dataset_x[num_train:, :]\n",
    "c_test = dataset_c[num_train:, :]\n",
    "num_test = c_test.shape[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Encoder(nn.Module):\n",
    "    def __init__(self, input_dim, c_dim, h_Q_dim, z_dim):\n",
    "        super(Encoder, self).__init__()\n",
    "        self.fc1  = nn.Linear(input_dim+c_dim, h_Q_dim)\n",
    "        self.fc2 = nn.Linear(h_Q_dim, h_Q_dim)\n",
    "        self.fc_mu = nn.Linear(h_Q_dim, z_dim)\n",
    "        self.fc_logvar = nn.Linear(h_Q_dim, z_dim)\n",
    "\n",
    "    def forward(self, x, c):\n",
    "        x = torch.cat((x, c), dim=1)\n",
    "        x = F.relu(self.fc1(x))\n",
    "        x = F.dropout(x, p=0.5)\n",
    "        x = F.relu(self.fc2(x))\n",
    "        # x = F.dropout(x, p=0.5)\n",
    "        # x = F.relu(self.fc2(x))\n",
    "        z_mu = self.fc_mu(x)\n",
    "        z_logvar = self.fc_logvar(x)\n",
    "        return z_mu, z_logvar\n",
    "    \n",
    "class Decoder(nn.Module):\n",
    "    def __init__(self, z_dim, c_dim, h_P_dim, X_dim):\n",
    "        super(Decoder, self).__init__()\n",
    "        self.fc1 = nn.Linear(z_dim + c_dim, h_P_dim)\n",
    "        self.fc2 = nn.Linear(h_P_dim, h_P_dim)\n",
    "        self.fc3 = nn.Linear(h_P_dim, X_dim)\n",
    "\n",
    "    def forward(self, z, c):\n",
    "        z = torch.cat((z, c), dim=1)\n",
    "        x = F.relu(self.fc1(z))\n",
    "        x = F.dropout(x, p=0.5)\n",
    "        x = F.relu(self.fc2(x))\n",
    "        # x = F.dropout(x, p=0.5)\n",
    "        # x = F.relu(self.fc2(x))\n",
    "        y = self.fc3(x)\n",
    "        return y\n",
    "    \n",
    "class CVAE(nn.Module):\n",
    "    def __init__(self, input_dim, c_dim, h_Q_dim, z_dim, h_P_dim, X_dim, lr=0.001):\n",
    "        super(CVAE, self).__init__()\n",
    "        self.encoder = Encoder(input_dim, c_dim, h_Q_dim, z_dim)\n",
    "        self.decoder = Decoder(z_dim, c_dim, h_P_dim, X_dim)\n",
    "        self.optimizer = optim.Adam(self.parameters(), lr=lr)\n",
    "        print(input_dim, c_dim, h_Q_dim, z_dim, h_P_dim, X_dim)\n",
    "\n",
    "    def forward(self, x, c):\n",
    "        z_mu, z_logvar = self.encoder(x, c)\n",
    "        eps = torch.randn_like(z_mu)\n",
    "        z = z_mu + torch.exp(z_logvar / 2) * eps\n",
    "        recon_x = self.decoder(z, c)\n",
    "        return recon_x, z_mu, z_logvar\n",
    "\n",
    "    def loss_function(self, recon_x, x, z_mu, z_logvar):\n",
    "        recon_loss = F.mse_loss(recon_x, x, reduction='none')\n",
    "        weights = torch.Tensor([[1]*60]).to(device)\n",
    "        weights = weights.repeat(256, 1)\n",
    "        recon_loss = recon_loss * weights\n",
    "        # recon_loss = recon_loss.mean()\n",
    "        # kl_loss = -0.5 * torch.sum(1 + z_logvar - z_mu.pow(2) - z_logvar.exp())\n",
    "        kl_loss = 10**-4 * 2 * torch.sum(torch.exp(z_logvar)+z_mu**2-1.-z_logvar, 1)\n",
    "        return torch.mean(torch.mean(recon_loss, 1) + kl_loss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "60 16 512 10 512 60\n"
     ]
    }
   ],
   "source": [
    "model = CVAE(X_dim, c_dim, h_Q_dim, z_dim, h_P_dim, X_dim, lr).to(device)\n",
    "optimizer = optim.Adam(model.parameters(), lr=lr)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Iter: 0\n",
      "Loss: 0.3661\n",
      "\n",
      "Iter: 1000\n",
      "Loss: 0.0088\n",
      "\n",
      "Iter: 2000\n",
      "Loss: 0.0069\n",
      "\n",
      "Iter: 3000\n",
      "Loss: 0.0056\n",
      "\n",
      "Iter: 4000\n",
      "Loss: 0.0045\n",
      "\n",
      "Iter: 5000\n",
      "Loss: 0.0040\n",
      "\n",
      "Iter: 6000\n",
      "Loss: 0.0035\n",
      "\n",
      "Iter: 7000\n",
      "Loss: 0.0033\n",
      "\n",
      "Iter: 8000\n",
      "Loss: 0.0030\n",
      "\n",
      "Iter: 9000\n",
      "Loss: 0.0028\n",
      "\n",
      "Iter: 10000\n",
      "Loss: 0.0027\n",
      "\n",
      "Iter: 11000\n",
      "Loss: 0.0025\n",
      "\n",
      "Iter: 12000\n",
      "Loss: 0.0022\n",
      "\n",
      "Iter: 13000\n",
      "Loss: 0.0020\n",
      "\n",
      "Iter: 14000\n",
      "Loss: 0.0020\n",
      "\n",
      "Iter: 15000\n",
      "Loss: 0.0019\n",
      "\n",
      "Iter: 16000\n",
      "Loss: 0.0017\n",
      "\n",
      "Iter: 17000\n",
      "Loss: 0.0016\n",
      "\n",
      "Iter: 18000\n",
      "Loss: 0.0015\n",
      "\n",
      "Iter: 19000\n",
      "Loss: 0.0015\n",
      "\n",
      "Iter: 20000\n",
      "Loss: 0.0015\n",
      "\n",
      "Iter: 21000\n",
      "Loss: 0.0014\n",
      "\n",
      "Iter: 22000\n",
      "Loss: 0.0014\n",
      "\n",
      "Iter: 23000\n",
      "Loss: 0.0012\n",
      "\n",
      "Iter: 24000\n",
      "Loss: 0.0012\n",
      "\n",
      "Iter: 25000\n",
      "Loss: 0.0011\n",
      "\n",
      "Iter: 26000\n",
      "Loss: 0.0010\n",
      "\n",
      "Iter: 27000\n",
      "Loss: 0.0009\n",
      "\n",
      "Iter: 28000\n",
      "Loss: 0.0009\n",
      "\n",
      "Iter: 29000\n",
      "Loss: 0.0008\n",
      "\n",
      "Iter: 30000\n",
      "Loss: 0.0007\n",
      "\n",
      "Iter: 31000\n",
      "Loss: 0.0008\n",
      "\n",
      "Iter: 32000\n",
      "Loss: 0.0006\n",
      "\n",
      "Iter: 33000\n",
      "Loss: 0.0007\n",
      "\n",
      "Iter: 34000\n",
      "Loss: 0.0007\n",
      "\n",
      "Iter: 35000\n",
      "Loss: 0.0006\n",
      "\n",
      "Iter: 36000\n",
      "Loss: 0.0006\n",
      "\n",
      "Iter: 37000\n",
      "Loss: 0.0006\n",
      "\n",
      "Iter: 38000\n",
      "Loss: 0.0006\n",
      "\n",
      "Iter: 39000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 40000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 41000\n",
      "Loss: 0.0006\n",
      "\n",
      "Iter: 42000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 43000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 44000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 45000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 46000\n",
      "Loss: 0.0004\n",
      "\n",
      "Iter: 47000\n",
      "Loss: 0.0004\n",
      "\n",
      "Iter: 48000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 49000\n",
      "Loss: 0.0005\n",
      "\n",
      "Iter: 50000\n",
      "Loss: 0.0004\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Training loop\n",
    "for it in range(50001):\n",
    "    # Randomly generate batches\n",
    "    indices = torch.randint(0, num_train, (mb_size,))\n",
    "    X_mb = torch.tensor(X_train[indices], dtype=torch.float32).to(device)\n",
    "    c_mb = torch.tensor(c_train[indices], dtype=torch.float32).to(device)\n",
    "    optimizer.zero_grad()\n",
    "    recon_batch, z_mu, z_logvar = model(X_mb, c_mb)\n",
    "    loss = model.loss_function(recon_batch, X_mb, z_mu, z_logvar)\n",
    "    loss.backward()\n",
    "    optimizer.step()\n",
    "\n",
    "    if it % 1000 == 0:\n",
    "        print('Iter: {}'.format(it))\n",
    "        print('Loss: {:.4f}'.format(loss.item()))\n",
    "        print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "705799\n",
      "0.0003204345703125\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAApUAAAGTCAYAAAB54OknAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/NK7nSAAAACXBIWXMAAAxOAAAMTgF/d4wjAAA++ElEQVR4nO3de5Bd5X3m++/7vmutfem77kKiESDkALYhGDgpzMwx9vEJqWNwxSQeT4VyVDEgu3ySmqgqtuMkNeUZj8uTqpFrxlM1lm2GGoqT+IzB8VC5zNQ4cFw4Yw+QsZ1YxAYliJZA9773vqy13vc9f+xGRgbsRqu3uqV+PlUN2nu/vdevtdTqR+/VxBgjIiIiIiIV2JUuQEREREQufAqVIiIiIlKZQqWIiIiIVKZQKSIiIiKVKVSKiIiISGUKlSIiIiJSmUKliIiIiFSWrHQBL3NpysDwupUuQ0RERGTZ5D6sdAnLKrZn6Xa7r/naqgmVA8Pr+OiXvrHSZYiIiIgsmyefn1zpEpbVjz73a6/7moa/RURERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCpTqBQRERGRyhQqRURERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCpTqBQRERGRyhQqRURERKSyJYXK3/qt32LHjh0YY/je9773uu3uv/9+rrrqKq688kruvfdeiqJYrjpFREREZBVbUqj8lV/5Fb71rW9x2WWXvW6b559/nj/4gz/giSee4ODBgxw/fpwvfvGLy1aoiIiIiKxeSwqV//gf/2O2b9/+U9s8/PDD3HnnnWzZsgVjDB/+8If54z/+42UpUkRERERWt2S53mhiYuKsnswdO3YwMTHxuu337dvHvn37zjzOO63lKkVEZFV48vnJlS5BXsfNl69b6RJELjortlBn7969HDly5MxHVm+uVCkiIiIiUtGyhcrx8XFeeOGFM48PHTrE+Pj4cr29iIiIiKxiyxYq77rrLh599FGOHTtGjJEvfOELfOADH1iutxcRERGRVWxJoXLPnj1s376dI0eO8Iu/+Ivs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EzfccAMPPfQQAI888gjbt29n586dZ7V7//vfz1NPPcXs7CwAf/7nf8511123zCWLiIiIyGqz5NXf+/fvZ/fu3XzmM59heHiYBx54AIB77rmHO++8kzvvvJPx8XE++clPcsstt2CtZdu2bXzxi1/sW/EiIiIisjqYGGNc6SIAhtdv5qNf+sZKlyEismyefP7i2VLt5svXrXQJIheki+nvAYAffe7XOHLkyGu+phN1RERERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCpTqBQRERGRyhQqRURERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCpTqBQRERGRyhQqRURERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpLJkpQsQERFZDj4U5KFFiB5rHJlt4my60mWJrBkKlSIickGLMdAqp+iEWYhgjO09Zyap22GayRjG/OyBOYVSkWoUKkVE5ILWKqdo+xkyO4Cx5szzMUbafgaAgXT9637+coVSkbVOoVJERC5YPhR0wmwvUJpeoPSxoPAdAiUmOmbjMWIEY8xr9kC+kVCq3kyR16dQKSIiF6w8tCBCxNMpF1gopyhDm9TVsSah7WdoFadpJZOM1rcDnNUDGaI/E0pj9LTKWbplC2MiCTWMdbTLw4ToiTFQ0FZvpsjrUKgUEZELlg8F7XKWYAraxSx5aJGYDB9ygg8EPBHH6e6LFLFktLaVmhuk7WeIMXL0737A03/xCNMvHSPvLGBrKUNbRtn2v1/L4M71JK5J043QKWYwzjLoNtJMR88EyKUOsYusBQqVIiJywer6eTphhrobIUZP041gjKEIOZPdv6fwOT52cKZJuzzNbH6E1DQ5+lcHeO4vvk13ep4QPgTxZmAImGPh6JMc//791EcH2HH7z7Pl1mup24KN2ZV04zymNDTTMaA3pJ7ZATphlnoY1lC4rGkKlSIickHyocCbnMQ0KMsOGIMxBh89k60JTnT+gTzMUXcjDCQRHwtac6c5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9u1nDX1Db67lo48+yrFjx4gx8oUvfIEPfECblYqIiIhc7Ja8+nv//v3s37+fXbt28dnPfpYHHngAgHvuuYdHH30UgCuuuIJPfepTvP3tb2fnzp1s3LiRPXv29KdyEREREVk1TIwxrnQR0JtT+dEvfWOlyxARERFZNk8+P7nSJSyrH33u1zhy5MhrvqYTdURERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCpTqBQRERGRyhQqRURERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCpTqBQRERGRyhQqRURERKQyhUoRERERqUyhUkREREQqU6gUERERkcoUKkVERESkMhNjjCtdBECtVmPjxo0rXcaymJ+fZ3BwcKXLkNeh+7N66d6sXro3q5vuz+p1sd2bkydP0u12X/O1VRMqLybbt2/nyJEjK12GvA7dn9VL92b10r1Z3XR/Vq+1dG80/C0iIiIilSlUioiIiEhlCpV9sHfv3pUuQX4K3Z/VS/dm9dK9Wd10f1avtXRvNKdSRERERCpTT6WIiIiIVKZQKSIiIiKVKVSeo+eee45bbrmFXbt2cdNNN3HgwIHXbHf//fdz1VVXceWVV3LvvfdSFMV5rnTtWcq9eeyxx7j55pu55ppruPbaa/nYxz5GCGEFql17lvq9AxBj5J3vfCejo6Pnr8A1bKn35m//9m95xzvewdVXX83VV1/N1772tfNc6dqzlHsTQmDv3r1cc801vPWtb+W2227j4MGDK1Dt2vJbv/Vb7NixA2MM3/ve91633ZrIA1HOyW233RYfeOCBGGOMX/3qV+ONN974qjb/8A//ELdu3RqPHj0aQwjxjjvuiP/+3//781zp2rOUe/O//tf/in//938fY4yx3W7Ht7/97Wc+R/prKffnZf/m3/ybeM8998SRkZHzU9wat5R7s7CwEC+//PL4xBNPxBhjLMsynjhx4nyWuSYt5d78yZ/8Sbz55ptjnucxxhj/5b/8l/FXf/VXz2eZa9I3v/nNePjw4XjZZZfF7373u6/ZZq3kAYXKc3D8+PE4NDQUi6KIMcYYQoibN2+Ozz333Fnt/vAP/zDu2bPnzOM/+7M/i29/+9vPa61rzVLvzU/66Ec/Gv/5P//n56HCte2N3J8f/OAH8R/9o38UDx48qFB5Hiz13nzpS1+K//Sf/tOVKHHNWuq9+frXvx6vu+66ODs7G0MI8Xd+53fib//2b69EyWvSTwuVayUPaPj7HBw+fJitW7eSJAkAxhjGx8eZmJg4q93ExASXXXbZmcc7dux4VRtZXku9N6907NgxHn74Yd7znvecrzLXrKXen6IouPfee9m/fz/OuZUodc1Z6r155plnqNVqvOc97+H666/ngx/8ICdPnlyJkteMpd6bO+64g3e84x1s2bKFrVu38pd/+Zf8i3/xL1aiZPkJayUPKFTKmjY7O8sdd9zBxz72MW688caVLkcWfepTn+J973sfV1999UqXIj+hLEu+8Y1vsH//fr773e+ybds2PvKRj6x0WQI8/fTT/OAHP+DFF1/kpZde4l3vehcf/vCHV7osWUMUKs/BpZdeytGjRynLEugtJpiYmGB8fPysduPj47zwwgtnHh86dOhVbWR5LfXeAMzNzXH77bfz3ve+d01tTruSlnp/vvnNb/L5z3+eHTt2cOuttzI7O8uOHTvUI9ZHb+Tvtdtuu41t27ZhjOHuu+/mO9/5zkqUvGYs9d48+OCDZxa2WWv59V//dR5//PGVKFl+wlrJAwqV52DTpk3ccMMNPPTQQwA88sgjbN++nZ07d57V7q677uLRRx/l2LFjxBj5whe+wAc+8IGVKHnNWOq9mZ+f5/bbb+f222/n93//91ei1DVpqffniSee4IUXXuDQoUN861vfYnh4mEOHDrFx48aVKHtNWOq9ef/7389TTz3F7OwsAH/+53/Oddddd97rXUuWem+uuOIKHnvsMfI8B+BP//RPefOb33ze65VXWzN5YAXnc17QfvjDH8Zf+IVfiFdddVV829veFv/mb/4mxhjjhz70ofhf/st/OdPui1/8YrziiiviFVdcEX/jN37jzKo86Z+l3JtPf/rTMUmSeN111535+PSnP72SZa8ZS/3eednzzz+vhTrnyVLvzYMPPhivvfba+Ja3vCXefvvtcWJiYqVKXjOWcm86nU6855574s/93M/Ft7zlLfHd7373mV0upH/uu+++uG3btuici5s2bYpXXnlljHFt5gEd0ygiIiIilWn4W0REREQqU6gUERERkcoUKkVERESkMoVKEREREalMoVJEREREKlOoFBEREZHKFCpFREREpDKFShERERGpTKFSRERERCr7/wGbeuL54x/4tAAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 800x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# plot \n",
    "num_viz = 50\n",
    "viz_idx = torch.randint(0, num_test-1, (1,))\n",
    "print(viz_idx.item())\n",
    "c_sample_seed = torch.tensor(c_test[viz_idx], dtype=torch.float32)\n",
    "c_sample = c_sample_seed.repeat(num_viz, 1).to(device)\n",
    "\n",
    "\n",
    "# obs\n",
    "gap = c_sample_seed[4:]\n",
    "obs1 = [0, gap[1], gap[0], gap[3]]\n",
    "obs2 = [gap[8], 0, gap[10], gap[9]]\n",
    "obs3 = [gap[8], gap[11], gap[9], 1]\n",
    "obs4 = [gap[2], gap[1], gap[4], gap[3]]\n",
    "obs5 = [gap[6], gap[1], 1, gap[3]]\n",
    "obsBounds = [-0.1, -0.1, -0.5, 0, 1.1, 1.5,\n",
    "             -0.1, -0.1, -0.5, 1.1, 0, 1.5,\n",
    "             -0.1, 1, -0.5, 1.1, 1.1, 1.5,\n",
    "             1, -0.1, -0.5, 1.1, 1.1, 1.5]\n",
    "dimW = 2\n",
    "plt.figure(figsize=(10, 6), dpi=80)\n",
    "plt.xlim(-0.1, 1.1)\n",
    "plt.ylim(-0.1, 1.1)\n",
    "\n",
    "obs = torch.tensor(np.concatenate((obs1, obs2, obs3, obs4, obs5, obsBounds), axis=0), dtype=torch.float32)\n",
    "for i in range(obs.shape[0] // (2 * dimW)):\n",
    "    plt.gca().add_patch(\n",
    "        patches.Rectangle(\n",
    "            (obs[i * 2 * dimW], obs[i * 2 * dimW + 1]),   # (x,y)\n",
    "            obs[i * 2 * dimW + dimW] - obs[i * 2 * dimW],  # width\n",
    "            obs[i * 2 * dimW + dimW + 1] - obs[i * 2 * dimW + 1],  # height\n",
    "            alpha=0.6\n",
    "        ))\n",
    "\n",
    "\n",
    "z_viz = torch.randn(num_viz, z_dim).to(device)\n",
    "with torch.no_grad():\n",
    "    cur_time = time.time()\n",
    "    y_viz = model.decoder(z_viz, c_sample).cpu().numpy()\n",
    "    print(time.time()-cur_time)\n",
    "\n",
    "for i in range(0, int(X_dim/2)):\n",
    "    plt.scatter(y_viz[:, i*2+0], y_viz[:, i*2+1], color=\"green\", s=70, alpha=0.1)\n",
    "\n",
    "plt.scatter(c_sample_seed[0], c_sample_seed[1], color='blue', s=250, edgecolors='black')\n",
    "plt.scatter(c_sample_seed[2], c_sample_seed[3], color='red', s=250, edgecolors='black')\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "jupyter",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
